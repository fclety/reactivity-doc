== Principles

=== Based on reactive streams

`Reactivity` architecture allows the system to face an unpredictible load of data when the users, the data sources or even the resources of some parties inside the information system scale.
This is why all the core http://www.reactive-streams.org[architecture] heavily uses the reactive streams where each service acts as a consumer and/or as a producer, emphasing an event-driven model in all layers.

=== Event-driven system

The event driven system is ready to route messages from source to sink in both live and batch contexts.
This need comes from the necessity to cover messaging based communication between the users and also asynchronous streams processing to prepare the data for some views.
Since everything is message, it's mandatory to expect that a message is going to be consumed by different consumers for different purpose.
This case is typically well illustrating by `RabbitMQ` documentation when talking about `direct exchange routing`.

image:https://www.rabbitmq.com/img/tutorials/intro/exchange-direct.png[]

We can see that there is as many consumer with different purpose as many routing keys are declared.
But it's important to notice that two consumers for the same purpose can be registered, and only one of them will consume the message.

=== Stream processing capabilities

`Reactivity` architecture expects a various number of streams and transformations of those streams.
The transformation phase requires messages to be delivered in the same order they are publishing.
This means also that if a consumer fails to acknowledge a message consumption, it must be able to easily retry to process the same message before treating a new one.

Transformation can be also aggregations to satisfy some user views requirements.
This means that a stream can be composed of different streams.

There is no reason to exclude some system interractions from the asynchronous messaging model.
Even a click from a user can be considered as a stream source.

image:https://camo.githubusercontent.com/36c0a9ffd8ed22236bd6237d44a1d3eecbaec336/687474703a2f2f692e696d6775722e636f6d2f634c344d4f73532e706e67[https://github.com/staltz]

This consideration can be wrong in a few cases where technical constraints make more realistic a different technique.   

=== Streaming platform

Routing messages with guarantee of delivery, ordering preservation, acknowledgement mechanism and high performance must be addressed by a distributed streaming platform.
That streaming platform will allow all producers and consumers to register themselves.
This is that platform that will receive all messages from producers and push them to consumers.

image:streaming-platform.png[]

=== Microservice architecture

The streaming platform will interact with producers and consumers in respect of http://www.martinfowler.com/articles/microservices.html[microservice architecture definition].
This mainly means that a consumer or a producer is considered as a component serving one purpose, exposing a clear API and easy to replace in the information system.

A microservice is autonomous as much as possible which is possible when control of data is decentralized.
Consumers and producers can take advantage of this by embedding their own database, which can lead to a duplication of data.
A consistency check mechanism should be considered to regularly make sure that a database is not incorrectly synchronized with others.
In case of unexpected desynchronization (typically a state that is expected to be synchronized regarding the messages that are delivered and those who are not), a re-initialization of that data should be possible.
Message streaming should be used as much as possible to replicate a data from scratch, including transformations process.

== Key technologies

=== Based on OSS

Technologies selected in respect of architecture principles must be open source.
Selection process must have a particular attention to the license to avoid patent or viral clause in the open source license.
`Apache 2.0` and `MIT` licenses are the typical open source license recommended for the technologies used by `Reactivity`.

=== Java 8 as base line version

The latest version of `Java` is the version 8.
This version will be used in the core of `Reactivity` as it's well maitained by `Oracle`, provides new features (especially around the `Stream` API) and is required by different technologies selected in the next section.

The goal of `Reactivity` is also to take advantage from the features introduced in next `Java` releases and be upgraded to `Java` 9 when available.

== Framework and platforms

=== Kafka as distributed streaming platform

http://kafka.apache.org[Apache Kafka] is the central platform of `Reactivity` that takes messages sent by producers and delivers them to consumers.
`Kafka` provides the key following benefits that make it a perfect solution for `Reactivity` requirements:

* *Scalability*: `Kafka` is distributed, which make that solution highly scalable. It uses https://zookeeper.apache.org[ZooKeeper] as service discovery system to keep the nodes in touch, which ease operations.
* *Ordering*: `Kafka` stores the messages in a partition that is ordered, giving the guarantee that messages have been consumed in the order they are emitted. This aspect is a key requirements for `Reactivity` as described in the architecture principles.
* *Acknowledgment*: Thanks to the offset commit technique, `Kafka` provides a very simple acknowledgement capability that consumers can use to guarantee that messages will be consumed in `Reactvity` system.
* *Consumer group*: `Kafka` allows consumers to be grouped with a simple label attached to them. This allows a message to be consumed for different purpose and to let the consumers scale without the risk to perform an action twice because of consumption duplication.

=== Spring 5 as consumer/producer stack

==== Spring Web Reactive

`Spring` version 5 comes with a http://docs.spring.io/spring-framework/docs/5.0.0.M1/spring-framework-reference/html/web-reactive.html[Spring Web Reactive] support which allows to exchange data in respect of reactive streams.
The core API implementation for reactive streams with `Spring` is https://projectreactor.io[Reactor].

Web Reactive support relies on servers without the requiring `Servlet` API, which means that `Netty` can be used as well as `Tomcat`.
The more focused, low-level approach of `Netty` fits nicely the scope of the consumer and the producer in `Reactivity`, which makes it a preferable solution.

On top of that, consumers and producers will be able to use the `REST` support in `Spring` WEB to easily collaborate with the other components of the system.
This communication interface can complement with additional `Spring` components described in the next sections.

==== Spring Data

In addition to the WEB module, `Spring Data` also uses `Reactor` to provide a complete asynchronous streaming pipeline from the database to the HTTP response.
The project offers a good level of abstraction with the different database providers and remains a strong partner in development using `Spring` when interractions with database are required.
Obviously, data need to be stored and read in `Reactivity`.
`Spring Data` will be key for this kind of manipulations.

==== Spring Cloud Stream

https://cloud.spring.io/spring-cloud-stream[Spring Cloud Stream] is a project that helps interacting with message driven middleware.
It provides a dedicated support for `Kafka` with an unified API that brings some abstractions in provider interractions.
This project will help consumers and producers to connect with `Kafka` in order to receive and emit messages.

==== Spring Cloud

http://projects.spring.io/spring-cloud[Spring Cloud] brings a lot of key components to address deployment issues for a application supposed to be scalable and highly available: 

* Service discovery of consumers and producers in the system to automatically scale
* Circuit breaker in consumers and producers in the system to be more fault-tolerant
* Property management to coordinate all consumers and producers configuration
* Client load balancing to easily control the trafic between components without the need to install a load balancer everywhere

==== Spring REST Docs

https://projects.spring.io/spring-restdocs[Spring REST Docs] provides a very handy way to document and test the APIs in a single activity.
It extends the integration testing API of `Spring` to build `AsciiDoc` files regarding the assertions performed on the services that are test.
This projects answer the need to documentation in an easy maintainance way.

==== Spring Security

http://projects.spring.io/spring-security[Spring Security] project provides a very large of techniques that allows to secure `Reactivity`.
This framework will be leverage on the consumers and producers that need to deal with user authentication and authorizations.

==== Spring Boot

http://projects.spring.io/spring-boot[Spring Boot] allows to quickly build a standalone component, easy to package in a uber JAR that make it easy to deploy and run.
This completely emphasizes the Microservice architecture style and will be a key framework to support consumers and producers development.

Almost all the `Spring` projects has support in `Spring Boot` that ease their integration with a `conventions over configuration` approach.

It also brings the key capabilities covering various issues of `Reactivity`:

* Monitoring of the different consumers and producers in the system with the `Actuator` module
* Integration testing of the services provided by the consumers and the producers
* Development tool with per environment configuration and hot reload support

=== Couchbase server as document database

WEB technologies such as `Javascript` describe object structures in `JSON` format.
This format is also used in document oriented databases.
Each artefact can be represented in a single document that will be loaded by the database when requested by the user in a particular view.
Some transformation results can be also represented in a document, which makes document database adapted for `Reactivity` requirements.

`Couchbase` is document oriented database and distributed by design that meets the scalability requirements of `Reactivity`.
This database also provides additional interesting products like embedded database for mobile that can be leveraged to cover new features.
This is why our primary choice goes for `Couchbase` server to store the data of `Reactivity`.
