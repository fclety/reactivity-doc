== Principles

`Reactivity` stores and exchange data in the `JSON` format.
One reason why `JSON` is used is the flexibility it offers in the data model.

This documentation describes the mandatory fields that must be found in a `JSON` document and which path can be freely structured.
The documentation also pays attention to the data model which is persisted to the database comparing to the informations dedicated to event types.
Moreover, since everything is stream in `Reactivity`, different fields of the data model are flagged to understand when they are defined and where they transit inside the system.

== Events stream

Data are always wrapped to an event.
This allows `Reactivity` to understand what to do with the data.
Therefore, any producer must use a particular data structure in their `JSON` document to wrap their data:

    {
		    "version" : "The module version",
		    "event" : "The event type here",
		    "data" : "The data here",
		    "timestamp" : "The event timestamp",
		    "id" : "The event ID",
		    "tag" : "A random value that looks like an UID"
    }
	
=== version

The `version` is a value indicating the version of the module that produces the message.
This version can be used by the consumer to know what kind of assertion can be made on the data.
By default, new version must be backward compatible which means that a consumer should be able to deal with an event flagged with an older version.

Version format follows the http://semver.org[semver] protocol.

=== event 

The `event` describes the nature of the message.
The possible values are an enumeration specific to the type of data contained inside the message.

No field in the message indicates the type of data because it corresponds to the topic they are published to.
In the core module, messages can be published to the following topic:

* `user`: the topic where events related to `Users` are published
* `organization`: the topic where events related to `Organization` are published  
* `artifact`: the topic where events related to `Artifacts` are published

This statement is true only when the client produce and consumes data directly from/to the topic (through `Kafka`).
However, there is the particular case of a WEB application subscribing to a source of events comming from a suspended `SSE` connection from the server.

         +--------------+-------------+
+------->|     Topic    |             |
|        +--------------+             |       +-----------------+
|        |     user     | Broadcaster |  SSE  |                 |
|        | organization |             |------>| Web Application |
|        |   artifact   |             |       |                 |
|        +--------------+-------------+       +-----------------+
|
|        +---------------------------+
|        |                           |
+--------+           KAFKA           |
         |                           |
         +---------------------------+

In this simple diagram we can see that the `Broadcaster` is consuming different topics from `Kafka`.
When a message is received, it's pushed to the web application that established a `SSE` connection.
The only chance for the web application to understand the type of data represented by a received message is to find `topic` attribute in the `JSON`.

    {
		    "topic" : "organization|user|artifact"
		    "version" : "...",
		    "event" : "...",
		    "data" : "...",
		    "timestamp" : "...",
		    "id" : "...",
		    "tag" : "..."
    }
		 
=== data

The `data` contains the payload of the event provided by the producer.
The structure of the data depends on the topic where is has been published, the `event` and `version` fields values.
The consumer will use those informations to know what structure is expected in the `data` value.

=== timestamp and id

`timestamp` and `id` are not defined by the producer but are assigned by the streaming platform.
They allow to identify the message inside `Reactivity` system and to know when it has been published by the consumer.

Therefore, a producer can generate a message that simply have this structure:


    {
		    "version" : "...",
		    "event" : "...",
		    "data" : "...",
		    "tag" : "..."
    }
	
=== tag

Since the `id` is not generated by the producer, it's not possible for him to recognize a produced message when it's received through another channel.
The `tag` allows him to address this issue.
The producer can associate a random value that looks like an unique UID to the `tag` attribute, allowing him to implement a kind of acknowledgment for the produced message.
This is particularly handy for web applications that receive a message previously produced.
In fact, the web application acts as a producer who expects to receive its own messages sent from the broadcaster.

    +----------------------------+ SSE - Consume message A  +-----------------+
+-->|     Topic ---> Broadcaster |------------------------->| Web Application |
|   +----------------------------+                          +-----------------+
|                                                                    |
|   +---------------------------+                                    |
|   |                           |         Produce message A          |
+---+           KAFKA           |<-----------------------------------+
    |                           |
    +---------------------------+

In this figure, we see that the message `A` produced by the web application is received from the broadcaster.
With the `tag` attribute whose value won't have been changed, the web application will be able to recognized it and to treat it differently comparing to the messages produced by other instances.
For example, the web application can perform an optimistic change on the UI as soon as the message is sent, giving a better feeling of performance to the user.
When the message is received, the web application can simply ignore it.
The web application can also raise an error if the message is never received (timeout), which means that the message has possibly been discarded for any reason.

=== Extensions

==== Additional data types definition

Extensions are allowed to define their own type of data stored in dedicated `buckets` (the document space in `Couchbase`) and sent through specific `topics` (in `Kafka`).
It's strongly recommended for an extension to use the same message structure described in previous sections.

To avoid clashes with build-in features of `Reactivity`, any extension `topic` and `bucket` must follow the pattern `[extension-id]/[topic-name]`.
The `extension-id` is an unique identifier for the extension in `Reactivity`.
This value must be used when the extension creates its own topic. 
The `topic-name` is a value each extension is free to define. 
This allows the extensions to define as much as data type they want and store their associated documents independently to the database.

==== Built-in data types extension

When an extension extends an existing data type (`Artifacts`, `Users` or `Organizations`), the mechanism is different.
The extension is allowed to modify the document created by the built-in features of `Reactivity`.
In that scenario, the extension is integrated to a stream processing module that intercepts messages comming from a targetted topic (`user`, `artifact` or `organization`).
The extension can validate the message payload and discard it in case of rule violation, modify the payload or trigger any specific action before the message is persisted. 

The extension is free to manage specific properties at any level of the message.
For instance:

    {
        "version" : "The module version", 
        "event" : "The event type here",
        "data" : {
            "my-extension-some-property" : "some value"
        },
        "timestamp" : "The event timestamp",
        "id" : "The event ID",
        "my-extension-some-property" : "some value"		
    }

It's strongly recommended that an extension does not add specific properties in a different place than what is defined in the above example.
Making assertion on the `data` field structure to add properties in a deeper path is possible but it would strongly couple the core with the extension, which would potentially lead to lots of regressions after a new release.

== Built-in data types and associated events

The following section describes the possible values for `data` and associated `event` attribute in a message provided by the core of `Reactivity`.

=== User

All messages related to the `User` data type are published to the `user` topic.

==== event = 'CREATE'

The `CREATE` event for a `User` has a `data` attribute associated to a value that looks like this:

TODO

==== event = 'READ'

The `READ` event for a `User` has a `data` attribute associated to a value that looks like this:

TODO

==== event = 'UPDATE'

The `UPDATE` event for a `User` has a `data` attribute associated to a value that looks like this:

TODO

==== event = 'DELETE'

The `DELETE` event for a `User` has a `data` attribute associated to a value that looks like this:

TODO

=== Organization

All messages related to the `Organization` data type are published to the `organization` topic.

==== event = 'CREATE'

The `CREATE` event for an `Organization` has a `data` attribute associated to a value that looks like this:

TODO

==== event = 'READ'

The `READ` event for an `Organization` has a `data` attribute associated to a value that looks like this:

TODO

==== event = 'UPDATE'

The `UPDATE` event for an `Organization` has a `data` attribute associated to a value that looks like this:

TODO

==== event = 'DELETE'

The `DELETE` event for an `Organization` has a `data` attribute associated to a value that looks like this:

TODO

==== event = 'READ_VIEW'

The `READ_VIEW` event for an `Organization` has a `data` attribute associated to a value that looks like this:

TODO

==== event = 'ADD_VIEW'

The `ADD_VIEW` event for an `Organization` has a `data` attribute associated to a value that looks like this:

TODO

==== event = 'REMOVE_VIEW'

The `REMOVE_VIEW` event for an `Organization` has a `data` attribute associated to a value that looks like this:

TODO

=== Artifact

All messages related to the `Artifact` data type are published to the `artifact` topic.

==== event = 'CREATE'

The `READ` event for an `Artifact` has a `data` attribute associated to a value that looks like this:

TODO

==== event = 'READ'

The `READ` event for an `Artifact` has a `data` attribute associated to a value that looks like this:

TODO

==== event = 'UPDATE'

The `UPDATE` event for an `Artifact` has a `data` attribute associated to a value that looks like this:

TODO

==== event = 'DELETE'

The `DELETE` event for an `Artifact` has a `data` attribute associated to a value that looks like this:

TODO
